import React, { useState, useEffect, useCallback } from 'react';
import {
  View,
  Text,
  StyleSheet,
  TouchableOpacity,
  ActivityIndicator,
  Alert,
  ScrollView,
  TextInput,
  KeyboardAvoidingView,
  Platform,
  Vibration,
} from 'react-native';
import { useSafeAreaInsets } from 'react-native-safe-area-context';
import { useNavigation, useRoute, RouteProp, CommonActions } from '@react-navigation/native';
import { Ionicons } from '@expo/vector-icons';
import type { ComponentProps } from 'react';
import { useTheme } from '../context/ThemeContext';
import { useAuth } from '../context/AuthContext';
import { useCart } from '../context/CartContext';
import { useTerminal } from '../context/StripeTerminalContext';
import { ordersApi, OrderPayment, stripeTerminalApi } from '../lib/api';
import { formatCents, getCurrencySymbol } from '../utils/currency';
import { glass } from '../lib/colors';
import { fonts } from '../lib/fonts';
import { shadows } from '../lib/shadows';
import { CardField, useConfirmPayment, CardFieldInput, initStripe } from '@stripe/stripe-react-native';
import { config } from '../lib/config';

type RouteParams = {
  SplitPayment: {
    orderId: string;
    orderNumber: string;
    totalAmount: number; // in cents
    customerEmail?: string;
  };
};

type PaymentMethod = 'card' | 'cash' | 'tap_to_pay';

export function SplitPaymentScreen() {
  const { colors, isDark } = useTheme();
  const { currency } = useAuth();
  const insets = useSafeAreaInsets();
  const navigation = useNavigation<any>();
  const route = useRoute<RouteProp<RouteParams, 'SplitPayment'>>();
  const { clearCart } = useCart();
  const glassColors = isDark ? glass.dark : glass.light;
  const { initializeTerminal, connectReader, processPayment: terminalProcessPayment } = useTerminal();
  const { confirmPayment } = useConfirmPayment();

  const { orderId, orderNumber, totalAmount, customerEmail } = route.params;

  const [payments, setPayments] = useState<OrderPayment[]>([]);
  const [totalPaid, setTotalPaid] = useState(0);
  const [remainingBalance, setRemainingBalance] = useState(totalAmount);
  const [isLoading, setIsLoading] = useState(true);
  const [isProcessing, setIsProcessing] = useState(false);

  // Add payment modal state
  const [showAddPayment, setShowAddPayment] = useState(false);
  const [selectedMethod, setSelectedMethod] = useState<PaymentMethod>('tap_to_pay');
  const [cardDetails, setCardDetails] = useState<CardFieldInput.Details | null>(null);
  const [paymentAmount, setPaymentAmount] = useState('');
  const [cashTendered, setCashTendered] = useState('');

  const styles = createStyles(colors, glassColors, isDark);

  // Fetch existing payments
  const fetchPayments = useCallback(async () => {
    try {
      const response = await ordersApi.getPayments(orderId);
      setPayments(response.payments);
      setTotalPaid(response.totalPaid);
      setRemainingBalance(response.remainingBalance);

      // Check if order is complete
      if (response.remainingBalance <= 0) {
        handleOrderComplete();
      }
    } catch (error: any) {
    } finally {
      setIsLoading(false);
    }
  }, [orderId]);

  useEffect(() => {
    fetchPayments();
  }, [fetchPayments]);

  const handleOrderComplete = () => {
    clearCart();
    navigation.dispatch(
      CommonActions.reset({
        index: 0,
        routes: [
          { name: 'MainTabs' },
          {
            name: 'PaymentResult',
            params: {
              success: true,
              amount: totalAmount,
              paymentIntentId: null,
              orderId,
              orderNumber,
              customerEmail,
              paymentMethod: 'split',
            },
          },
        ],
      })
    );
  };

  // Process tap to pay payment (Terminal SDK via context)
  const processTapToPayPayment = async (amount: number) => {
    setIsProcessing(true);
    try {
      // Ensure terminal is initialized and reader connected
      await initializeTerminal();
      await connectReader();

      // Create payment intent via API
      const piResponse = await stripeTerminalApi.createPaymentIntent({
        amount: amount / 100, // Convert cents to dollars for API
      });

      // Initialize Stripe SDK with connected account for Terminal PI retrieval
      await initStripe({
        publishableKey: config.stripePublishableKey,
        merchantIdentifier: 'merchant.com.lumapos',
        stripeAccountId: piResponse.stripeAccountId,
      });

      // Process payment through the Terminal context (retrieve → collect → confirm)
      const result = await terminalProcessPayment(piResponse.clientSecret);

      if (result.status !== 'succeeded') {
        throw new Error(`Payment status: ${result.status}`);
      }

      await ordersApi.addPayment(orderId, {
        paymentMethod: 'tap_to_pay',
        amount,
        stripePaymentIntentId: piResponse.id,
      });

      await fetchPayments();
      setShowAddPayment(false);
      resetPaymentForm();
    } catch (error: any) {
      Alert.alert('Payment Failed', error.message || 'Failed to process tap to pay payment');
    } finally {
      setIsProcessing(false);
    }
  };

  // Process manual card entry payment (regular Stripe SDK)
  const processManualCardPayment = async (amount: number) => {
    if (!cardDetails?.complete) {
      Alert.alert('Card Required', 'Please enter your card details.');
      return;
    }

    setIsProcessing(true);
    try {
      const paymentIntent = await stripeTerminalApi.createPaymentIntent({
        amount: amount / 100,
        orderId,
        isQuickCharge: false,
        captureMethod: 'automatic',
        paymentMethodType: 'card',
      });

      await initStripe({
        publishableKey: config.stripePublishableKey,
        merchantIdentifier: 'merchant.com.lumapos',
        stripeAccountId: paymentIntent.stripeAccountId,
      });

      const { error, paymentIntent: confirmedIntent } = await confirmPayment(paymentIntent.clientSecret, {
        paymentMethodType: 'Card',
        paymentMethodData: {
          billingDetails: {
            email: customerEmail || undefined,
          },
        },
      });

      if (error) {
        throw new Error(error.message || 'Payment failed');
      }

      if (confirmedIntent?.status !== 'Succeeded') {
        throw new Error('Payment was not successful');
      }

      await ordersApi.addPayment(orderId, {
        paymentMethod: 'card',
        amount,
        stripePaymentIntentId: paymentIntent.id,
      });

      await fetchPayments();
      setShowAddPayment(false);
      resetPaymentForm();
    } catch (error: any) {
      Alert.alert('Payment Failed', error.message || 'Failed to process card payment');
    } finally {
      setIsProcessing(false);
    }
  };

  // Process cash payment
  const processCashPayment = async (amount: number, tendered: number) => {
    setIsProcessing(true);
    try {
      await ordersApi.addPayment(orderId, {
        paymentMethod: 'cash',
        amount,
        cashTendered: tendered,
      });

      // Show change if any
      const change = tendered - amount;
      if (change > 0) {
        Alert.alert('Change Due', `Give customer ${formatCents(change, currency)} in change`);
      }

      // Refresh payments
      await fetchPayments();
      setShowAddPayment(false);
      resetPaymentForm();
    } catch (error: any) {
      Alert.alert('Payment Failed', error.message || 'Failed to process cash payment');
    } finally {
      setIsProcessing(false);
    }
  };

  const resetPaymentForm = () => {
    setPaymentAmount('');
    setCashTendered('');
    setCardDetails(null);
    setSelectedMethod('tap_to_pay');
  };

  const MIN_STRIPE_AMOUNT_CENTS = 50; // $0.50 minimum for Stripe

  const amountCents = Math.round(parseFloat(paymentAmount || '0') * 100);
  const isStripeMethod = selectedMethod === 'tap_to_pay' || selectedMethod === 'card';
  const isBelowStripeMinimum = isStripeMethod && amountCents > 0 && amountCents < MIN_STRIPE_AMOUNT_CENTS;

  // Auto-switch to cash if remaining balance drops below Stripe minimum
  useEffect(() => {
    if (remainingBalance > 0 && remainingBalance < MIN_STRIPE_AMOUNT_CENTS && (selectedMethod === 'tap_to_pay' || selectedMethod === 'card')) {
      setSelectedMethod('cash');
    }
  }, [remainingBalance, selectedMethod]);

  const handleAddPayment = async () => {
    if (amountCents <= 0) {
      Alert.alert('Invalid Amount', 'Please enter a valid payment amount');
      return;
    }

    if (amountCents > remainingBalance) {
      Alert.alert('Amount Too High', `Maximum payment is ${formatCents(remainingBalance, currency)}`);
      return;
    }

    if (selectedMethod === 'cash') {
      const tenderedCents = Math.round(parseFloat(cashTendered || '0') * 100);
      if (tenderedCents < amountCents) {
        Alert.alert('Insufficient Cash', 'Cash tendered must be at least the payment amount');
        return;
      }
      await processCashPayment(amountCents, tenderedCents);
    } else if (selectedMethod === 'tap_to_pay') {
      await processTapToPayPayment(amountCents);
    } else {
      await processManualCardPayment(amountCents);
    }
  };

  const handlePayRemaining = () => {
    setPaymentAmount((remainingBalance / 100).toFixed(2));
  };

  const getPaymentMethodIcon = (method: PaymentMethod): ComponentProps<typeof Ionicons>['name'] => {
    switch (method) {
      case 'cash':
        return 'cash-outline';
      case 'card':
        return 'card-outline';
      case 'tap_to_pay':
        return 'phone-portrait-outline';
      default:
        return 'card-outline';
    }
  };

  const getPaymentMethodLabel = (method: PaymentMethod): string => {
    switch (method) {
      case 'cash':
        return 'Cash';
      case 'card':
        return 'Card';
      case 'tap_to_pay':
        return 'Tap to Pay';
      default:
        return 'Card';
    }
  };

  if (isLoading) {
    return (
      <View style={[styles.container, { paddingTop: insets.top, paddingBottom: insets.bottom }]}>
        <View style={styles.loadingContainer}>
          <ActivityIndicator size="large" color={colors.primary} accessibilityLabel="Loading payment details" />
        </View>
      </View>
    );
  }

  return (
    <View style={[styles.container, { paddingTop: insets.top, paddingBottom: insets.bottom }]}>
      <KeyboardAvoidingView
        behavior={Platform.OS === 'ios' ? 'padding' : 'height'}
        style={styles.keyboardView}
        keyboardVerticalOffset={Platform.OS === 'ios' ? 10 : 0}
      >
        {/* Header */}
        <View style={styles.header}>
          <TouchableOpacity
            style={styles.backButton}
            onPress={() => navigation.goBack()}
            accessibilityRole="button"
            accessibilityLabel="Go back"
          >
            <Ionicons name="arrow-back" size={24} color={colors.text} />
          </TouchableOpacity>
          <Text style={styles.headerTitle} maxFontSizeMultiplier={1.3}>Split Payment</Text>
          <View style={{ width: 48 }} />
        </View>

        <ScrollView
          style={styles.scrollView}
          contentContainerStyle={styles.scrollContent}
          keyboardShouldPersistTaps="handled"
          automaticallyAdjustKeyboardInsets
        >
          {/* Order Summary */}
          <View style={styles.summaryCard} accessibilityRole="summary" accessibilityLabel={`Order total ${formatCents(totalAmount, currency)}, paid ${formatCents(totalPaid, currency)}, remaining ${formatCents(remainingBalance, currency)}`}>
            <View style={styles.summaryRow}>
              <Text style={styles.summaryLabel} maxFontSizeMultiplier={1.5}>Order Total</Text>
              <Text style={styles.summaryValue} maxFontSizeMultiplier={1.3}>{formatCents(totalAmount, currency)}</Text>
            </View>
            <View style={styles.summaryRow}>
              <Text style={styles.summaryLabel} maxFontSizeMultiplier={1.5}>Total Paid</Text>
              <Text style={[styles.summaryValue, { color: colors.success }]} maxFontSizeMultiplier={1.3}>
                {formatCents(totalPaid, currency)}
              </Text>
            </View>
            <View style={[styles.summaryRow, styles.remainingRow]}>
              <Text style={styles.remainingLabel} maxFontSizeMultiplier={1.5}>Remaining</Text>
              <Text style={styles.remainingValue} maxFontSizeMultiplier={1.2}>{formatCents(remainingBalance, currency)}</Text>
            </View>
          </View>

          {/* Existing Payments */}
          {payments.length > 0 && (
            <View style={styles.paymentsSection}>
              <Text style={styles.sectionTitle} maxFontSizeMultiplier={1.5}>Payments</Text>
              {payments.map((payment, index) => (
                <View key={payment.id || index} style={styles.paymentRow}>
                  <View style={styles.paymentLeft}>
                    <Ionicons
                      name={getPaymentMethodIcon(payment.paymentMethod)}
                      size={20}
                      color={colors.primary}
                    />
                    <Text style={styles.paymentMethod} maxFontSizeMultiplier={1.5}>
                      {getPaymentMethodLabel(payment.paymentMethod)}
                    </Text>
                  </View>
                  <Text style={styles.paymentAmount} maxFontSizeMultiplier={1.5}>
                    {formatCents(payment.amount, currency)}
                  </Text>
                </View>
              ))}
            </View>
          )}

          {/* Add Payment Section */}
          {remainingBalance > 0 && (
            <View style={styles.addPaymentSection}>
              {!showAddPayment ? (
                <TouchableOpacity
                  style={styles.addPaymentButton}
                  onPress={() => setShowAddPayment(true)}
                  accessibilityRole="button"
                  accessibilityLabel="Add payment"
                  accessibilityHint={`${formatCents(remainingBalance, currency)} remaining`}
                >
                  <Ionicons name="add-circle-outline" size={24} color={colors.primary} />
                  <Text style={styles.addPaymentButtonText} maxFontSizeMultiplier={1.3}>Add Payment</Text>
                </TouchableOpacity>
              ) : (
                <View style={styles.paymentForm}>
                  <Text style={styles.formTitle} maxFontSizeMultiplier={1.3}>Add Payment</Text>

                  {/* Payment Method Selection */}
                  <View style={styles.methodSelection}>
                    {(['tap_to_pay', 'card', 'cash'] as PaymentMethod[]).map((method) => {
                      const isStripe = method === 'tap_to_pay' || method === 'card';
                      const belowMin = isStripe && remainingBalance < MIN_STRIPE_AMOUNT_CENTS;
                      return (
                        <TouchableOpacity
                          key={method}
                          style={[
                            styles.methodButton,
                            selectedMethod === method && styles.methodButtonSelected,
                            belowMin && styles.methodButtonDisabled,
                          ]}
                          onPress={() => setSelectedMethod(method)}
                          disabled={belowMin}
                          accessibilityRole="button"
                          accessibilityLabel={`${getPaymentMethodLabel(method)}${belowMin ? ', unavailable, below minimum' : ''}`}
                          accessibilityState={{ selected: selectedMethod === method, disabled: belowMin }}
                        >
                          <Ionicons
                            name={getPaymentMethodIcon(method)}
                            size={20}
                            color={belowMin ? colors.textMuted : selectedMethod === method ? '#fff' : colors.text}
                          />
                          <Text
                            style={[
                              styles.methodButtonText,
                              selectedMethod === method && styles.methodButtonTextSelected,
                              belowMin && styles.methodButtonTextDisabled,
                            ]}
                            maxFontSizeMultiplier={1.3}
                          >
                            {getPaymentMethodLabel(method)}
                          </Text>
                        </TouchableOpacity>
                      );
                    })}
                  </View>

                  {/* Stripe minimum warning */}
                  {isBelowStripeMinimum && (
                    <View style={styles.minimumWarning} accessibilityRole="alert">
                      <Ionicons name="warning" size={16} color={colors.warning} style={styles.minimumWarningIcon} />
                      <Text style={styles.minimumWarningText} maxFontSizeMultiplier={1.5}>
                        {`Minimum for ${selectedMethod === 'tap_to_pay' ? 'Tap to Pay' : 'Card'} is ${formatCents(50, currency)}. Use cash for smaller amounts.`}
                      </Text>
                    </View>
                  )}

                  {/* Amount Input */}
                  <View style={styles.inputGroup}>
                    <Text style={styles.inputLabel} maxFontSizeMultiplier={1.5}>Payment Amount</Text>
                    <View style={styles.amountInputContainer}>
                      <Text style={styles.dollarSign} maxFontSizeMultiplier={1.3}>{getCurrencySymbol(currency)}</Text>
                      <TextInput
                        style={styles.amountInput}
                        value={paymentAmount}
                        onChangeText={setPaymentAmount}
                        keyboardType="decimal-pad"
                        placeholder="0.00"
                        placeholderTextColor={colors.textMuted}
                        accessibilityLabel="Payment amount"
                      />
                      <TouchableOpacity
                        style={styles.remainingButton}
                        onPress={handlePayRemaining}
                        accessibilityRole="button"
                        accessibilityLabel={`Fill remaining balance ${formatCents(remainingBalance, currency)}`}
                      >
                        <Text style={styles.remainingButtonText} maxFontSizeMultiplier={1.3}>Remaining</Text>
                      </TouchableOpacity>
                    </View>
                  </View>

                  {/* Cash Tendered (for cash payments) */}
                  {selectedMethod === 'cash' && (
                    <View style={styles.inputGroup}>
                      <Text style={styles.inputLabel} maxFontSizeMultiplier={1.5}>Cash Tendered</Text>
                      <View style={styles.amountInputContainer}>
                        <Text style={styles.dollarSign} maxFontSizeMultiplier={1.3}>{getCurrencySymbol(currency)}</Text>
                        <TextInput
                          style={styles.amountInput}
                          value={cashTendered}
                          onChangeText={setCashTendered}
                          keyboardType="decimal-pad"
                          placeholder="0.00"
                          placeholderTextColor={colors.textMuted}
                          accessibilityLabel="Cash tendered amount"
                        />
                      </View>
                      {/* Change calculation */}
                      {cashTendered && paymentAmount && (
                        <View style={styles.changeDisplay}>
                          <Text style={styles.changeLabel} maxFontSizeMultiplier={1.5}>Change Due:</Text>
                          <Text style={styles.changeAmount} maxFontSizeMultiplier={1.3}>
                            {formatCents(Math.round(Math.max(0, (parseFloat(cashTendered) - parseFloat(paymentAmount))) * 100), currency)}
                          </Text>
                        </View>
                      )}
                    </View>
                  )}

                  {/* Card Entry (for manual card payments) */}
                  {selectedMethod === 'card' && (
                    <View style={styles.inputGroup}>
                      <Text style={styles.inputLabel} maxFontSizeMultiplier={1.5}>Card Details</Text>
                      <CardField
                        postalCodeEnabled={false}
                        cardStyle={{
                          backgroundColor: isDark ? colors.card : '#FFFFFF',
                          textColor: colors.text,
                          placeholderColor: colors.textMuted,
                          borderColor: glassColors.border,
                          borderWidth: 1,
                          borderRadius: 12,
                          fontSize: 16,
                        }}
                        style={{ width: '100%', height: 50, marginTop: 8 }}
                        onCardChange={setCardDetails}
                      />
                    </View>
                  )}

                  {/* Form Actions */}
                  <View style={styles.formActions}>
                    <TouchableOpacity
                      style={styles.cancelFormButton}
                      onPress={() => {
                        setShowAddPayment(false);
                        resetPaymentForm();
                      }}
                      accessibilityRole="button"
                      accessibilityLabel="Cancel adding payment"
                    >
                      <Text style={styles.cancelFormButtonText} maxFontSizeMultiplier={1.3}>Cancel</Text>
                    </TouchableOpacity>
                    <TouchableOpacity
                      style={[
                        styles.processButton,
                        (isProcessing || isBelowStripeMinimum) && styles.processButtonDisabled,
                      ]}
                      onPress={handleAddPayment}
                      disabled={isProcessing || isBelowStripeMinimum}
                      accessibilityRole="button"
                      accessibilityLabel={isProcessing ? 'Processing payment' : 'Process payment'}
                      accessibilityState={{ disabled: isProcessing || isBelowStripeMinimum }}
                    >
                      {isProcessing ? (
                        <ActivityIndicator color="#fff" size="small" accessibilityLabel="Processing payment" />
                      ) : (
                        <>
                          <Ionicons name="checkmark-circle" size={20} color="#fff" />
                          <Text style={styles.processButtonText} maxFontSizeMultiplier={1.3}>Process</Text>
                        </>
                      )}
                    </TouchableOpacity>
                  </View>
                </View>
              )}
            </View>
          )}
        </ScrollView>

        {/* Footer - Complete if balance is 0 */}
        {remainingBalance <= 0 && (
          <View style={styles.footer}>
            <TouchableOpacity
              style={styles.completeButton}
              onPress={handleOrderComplete}
              accessibilityRole="button"
              accessibilityLabel="Payment complete"
              accessibilityHint="Finish the order and go to results"
            >
              <Ionicons name="checkmark-circle" size={24} color="#fff" />
              <Text style={styles.completeButtonText} maxFontSizeMultiplier={1.3}>Payment Complete</Text>
            </TouchableOpacity>
          </View>
        )}
      </KeyboardAvoidingView>
    </View>
  );
}

const createStyles = (colors: any, glassColors: typeof glass.dark, isDark: boolean) =>
  StyleSheet.create({
    container: {
      flex: 1,
      backgroundColor: colors.background,
    },
    keyboardView: {
      flex: 1,
    },
    loadingContainer: {
      flex: 1,
      alignItems: 'center',
      justifyContent: 'center',
    },
    header: {
      flexDirection: 'row',
      alignItems: 'center',
      justifyContent: 'space-between',
      paddingHorizontal: 16,
      paddingVertical: 12,
      backgroundColor: glassColors.backgroundSubtle,
      borderBottomWidth: 1,
      borderBottomColor: glassColors.borderSubtle,
    },
    backButton: {
      width: 48,
      height: 48,
      alignItems: 'center',
      justifyContent: 'center',
      backgroundColor: glassColors.backgroundElevated,
      borderRadius: 16,
      borderWidth: 1,
      borderColor: glassColors.border,
    },
    headerTitle: {
      fontSize: 18,
      fontFamily: fonts.semiBold,
      color: colors.text,
    },
    scrollView: {
      flex: 1,
    },
    scrollContent: {
      padding: 20,
    },
    summaryCard: {
      backgroundColor: glassColors.backgroundElevated,
      borderRadius: 20,
      padding: 20,
      borderWidth: 1,
      borderColor: glassColors.border,
      marginBottom: 20,
      ...shadows.md,
    },
    summaryRow: {
      flexDirection: 'row',
      justifyContent: 'space-between',
      alignItems: 'center',
      marginBottom: 12,
    },
    summaryLabel: {
      fontSize: 15,
      fontFamily: fonts.medium,
      color: colors.textSecondary,
    },
    summaryValue: {
      fontSize: 17,
      fontFamily: fonts.semiBold,
      color: colors.text,
    },
    remainingRow: {
      marginBottom: 0,
      paddingTop: 12,
      borderTopWidth: 1,
      borderTopColor: glassColors.borderSubtle,
    },
    remainingLabel: {
      fontSize: 16,
      fontFamily: fonts.semiBold,
      color: colors.text,
    },
    remainingValue: {
      fontSize: 24,
      fontFamily: fonts.bold,
      color: colors.primary,
    },
    paymentsSection: {
      marginBottom: 20,
    },
    sectionTitle: {
      fontSize: 16,
      fontFamily: fonts.semiBold,
      color: colors.text,
      marginBottom: 12,
    },
    paymentRow: {
      flexDirection: 'row',
      justifyContent: 'space-between',
      alignItems: 'center',
      backgroundColor: glassColors.backgroundElevated,
      borderRadius: 12,
      padding: 14,
      borderWidth: 1,
      borderColor: glassColors.border,
      marginBottom: 8,
    },
    paymentLeft: {
      flexDirection: 'row',
      alignItems: 'center',
      gap: 10,
    },
    paymentMethod: {
      fontSize: 15,
      fontFamily: fonts.medium,
      color: colors.text,
    },
    paymentAmount: {
      fontSize: 16,
      fontFamily: fonts.semiBold,
      color: colors.success,
    },
    addPaymentSection: {
      marginTop: 8,
    },
    addPaymentButton: {
      flexDirection: 'row',
      alignItems: 'center',
      justifyContent: 'center',
      gap: 10,
      paddingVertical: 16,
      backgroundColor: glassColors.backgroundElevated,
      borderRadius: 16,
      borderWidth: 1,
      borderColor: colors.primary + '40',
      borderStyle: 'dashed',
    },
    addPaymentButtonText: {
      fontSize: 16,
      fontFamily: fonts.semiBold,
      color: colors.primary,
    },
    paymentForm: {
      backgroundColor: glassColors.backgroundElevated,
      borderRadius: 20,
      padding: 20,
      borderWidth: 1,
      borderColor: glassColors.border,
      ...shadows.md,
    },
    formTitle: {
      fontSize: 18,
      fontFamily: fonts.semiBold,
      color: colors.text,
      marginBottom: 16,
    },
    methodSelection: {
      flexDirection: 'row',
      gap: 10,
      marginBottom: 20,
    },
    methodButton: {
      flex: 1,
      flexDirection: 'row',
      alignItems: 'center',
      justifyContent: 'center',
      gap: 6,
      paddingVertical: 12,
      borderRadius: 12,
      backgroundColor: glassColors.background,
      borderWidth: 1,
      borderColor: glassColors.border,
    },
    methodButtonSelected: {
      backgroundColor: colors.primary,
      borderColor: colors.primary,
    },
    methodButtonDisabled: {
      opacity: 0.4,
    },
    methodButtonText: {
      fontSize: 13,
      fontFamily: fonts.medium,
      color: colors.text,
    },
    methodButtonTextSelected: {
      color: '#fff',
    },
    methodButtonTextDisabled: {
      color: colors.textMuted,
    },
    minimumWarning: {
      flexDirection: 'row',
      alignItems: 'flex-start',
      gap: 8,
      backgroundColor: colors.warning + '15',
      borderRadius: 10,
      paddingHorizontal: 12,
      paddingVertical: 10,
      marginBottom: 16,
      borderWidth: 1,
      borderColor: colors.warning + '30',
    },
    minimumWarningIcon: {
      marginTop: 1,
    },
    minimumWarningText: {
      flex: 1,
      fontSize: 13,
      fontFamily: fonts.medium,
      color: colors.warning,
      lineHeight: 18,
    },
    inputGroup: {
      marginBottom: 16,
    },
    inputLabel: {
      fontSize: 14,
      fontFamily: fonts.medium,
      color: colors.textSecondary,
      marginBottom: 8,
    },
    amountInputContainer: {
      flexDirection: 'row',
      alignItems: 'center',
      backgroundColor: glassColors.background,
      borderRadius: 12,
      borderWidth: 1,
      borderColor: glassColors.border,
      paddingHorizontal: 14,
    },
    dollarSign: {
      fontSize: 20,
      fontFamily: fonts.semiBold,
      color: colors.textSecondary,
      marginRight: 4,
    },
    amountInput: {
      flex: 1,
      fontSize: 20,
      fontFamily: fonts.semiBold,
      color: colors.text,
      paddingVertical: 14,
    },
    remainingButton: {
      backgroundColor: colors.primary + '20',
      paddingHorizontal: 12,
      paddingVertical: 8,
      borderRadius: 8,
    },
    remainingButtonText: {
      fontSize: 13,
      fontFamily: fonts.medium,
      color: colors.primary,
    },
    changeDisplay: {
      flexDirection: 'row',
      alignItems: 'center',
      justifyContent: 'space-between',
      marginTop: 10,
      paddingHorizontal: 4,
    },
    changeLabel: {
      fontSize: 14,
      fontFamily: fonts.medium,
      color: colors.success,
    },
    changeAmount: {
      fontSize: 18,
      fontFamily: fonts.bold,
      color: colors.success,
    },
    formActions: {
      flexDirection: 'row',
      gap: 12,
      marginTop: 8,
    },
    cancelFormButton: {
      flex: 1,
      paddingVertical: 14,
      borderRadius: 12,
      borderWidth: 1,
      borderColor: colors.border,
      alignItems: 'center',
    },
    cancelFormButtonText: {
      fontSize: 16,
      fontFamily: fonts.semiBold,
      color: colors.text,
    },
    processButton: {
      flex: 2,
      flexDirection: 'row',
      alignItems: 'center',
      justifyContent: 'center',
      gap: 8,
      paddingVertical: 14,
      borderRadius: 12,
      backgroundColor: colors.success,
    },
    processButtonDisabled: {
      opacity: 0.6,
    },
    processButtonText: {
      fontSize: 16,
      fontFamily: fonts.semiBold,
      color: '#fff',
    },
    footer: {
      padding: 20,
      paddingBottom: 36,
    },
    completeButton: {
      flexDirection: 'row',
      alignItems: 'center',
      justifyContent: 'center',
      paddingVertical: 18,
      borderRadius: 20,
      backgroundColor: colors.success,
      gap: 10,
      ...shadows.md,
    },
    completeButtonText: {
      fontSize: 18,
      fontFamily: fonts.semiBold,
      color: '#fff',
    },
  });
