import React, { createContext, useContext, useState, useEffect, useCallback, useRef } from 'react';
import { Alert, Image } from 'react-native';
import { authService, User, Organization, Subscription, stripeConnectApi, ConnectStatus } from '../lib/api';
import { setOnSessionKicked, apiClient } from '../lib/api/client';
import { setOnSocketSessionKicked } from '../lib/session-callbacks';
import {
  checkBiometricCapabilities,
  isBiometricLoginEnabled,
  BiometricCapabilities,
} from '../lib/biometricAuth';
import logger from '../lib/logger';

interface AuthState {
  user: User | null;
  organization: Organization | null;
  subscription: Subscription | null;
  isLoading: boolean;
  isAuthenticated: boolean;
  connectStatus: ConnectStatus | null;
  isPaymentReady: boolean;
  connectLoading: boolean;
  biometricCapabilities: BiometricCapabilities | null;
  biometricEnabled: boolean;
}

interface AuthContextType extends AuthState {
  signIn: (email: string, password: string) => Promise<void>;
  signOut: () => Promise<void>;
  refreshAuth: () => Promise<void>;
  refreshConnectStatus: () => Promise<void>;
  completeOnboarding: () => Promise<void>;
  setBiometricEnabled: (enabled: boolean) => void;
  refreshBiometricStatus: () => Promise<void>;
}

const AuthContext = createContext<AuthContextType | undefined>(undefined);

export function AuthProvider({ children }: { children: React.ReactNode }) {
  const [state, setState] = useState<AuthState>({
    user: null,
    organization: null,
    subscription: null,
    isLoading: true,
    isAuthenticated: false,
    connectStatus: null,
    isPaymentReady: false,
    connectLoading: true,
    biometricCapabilities: null,
    biometricEnabled: false,
  });

  // Track if we're already showing a session kicked alert
  const sessionKickedAlertShown = useRef(false);

  // Handle session kicked (user logged in on another device)
  const handleSessionKicked = useCallback(async () => {
    // Prevent showing multiple alerts
    if (sessionKickedAlertShown.current) {
      return;
    }
    sessionKickedAlertShown.current = true;

    logger.log('[AuthContext] Session kicked - signing out user');

    // Clear auth data immediately
    try {
      await authService.logout();
    } catch (error) {
      logger.error('[AuthContext] Error during session kicked logout:', error);
    }

    // Update state
    setState({
      user: null,
      organization: null,
      subscription: null,
      isLoading: false,
      isAuthenticated: false,
      connectStatus: null,
      isPaymentReady: false,
      connectLoading: false,
      biometricCapabilities: null,
      biometricEnabled: false,
    });

    // Show alert to user
    Alert.alert(
      'Session Ended',
      'You have been signed out because your account was signed in on another device.',
      [{ text: 'OK', onPress: () => { sessionKickedAlertShown.current = false; } }]
    );
  }, []);

  // Set up the session kicked callbacks for both API client and socket
  useEffect(() => {
    setOnSessionKicked(handleSessionKicked);
    setOnSocketSessionKicked(handleSessionKicked);
  }, [handleSessionKicked]);

  // Load cached user/org and stop loading immediately if we have cached data
  const loadCachedAuth = useCallback(async (): Promise<boolean> => {
    try {
      logger.log('[AuthContext] loadCachedAuth: checking authentication...');
      const isAuthenticated = await authService.isAuthenticated();
      logger.log('[AuthContext] loadCachedAuth: isAuthenticated =', isAuthenticated);

      if (!isAuthenticated) {
        logger.log('[AuthContext] loadCachedAuth: no token, setting isLoading=false');
        setState(prev => ({ ...prev, isLoading: false }));
        return false;
      }

      // Try to get cached user/org/subscription
      const user = await authService.getUser();
      const organization = await authService.getOrganization();
      const subscription = await authService.getSubscription();
      logger.log('[AuthContext] loadCachedAuth: cached user =', user?.email, ', org =', organization?.name, ', subscription =', subscription?.tier);

      if (user && organization) {
        // We have cached data, show it immediately
        logger.log('[AuthContext] loadCachedAuth: using cached data');
        setState(prev => ({
          ...prev,
          user,
          organization,
          subscription,
          isLoading: false,
          isAuthenticated: true,
        }));
        return true;
      }

      // Token exists but no cached data - keep isLoading true, refreshProfileFromAPI will handle it
      logger.log('[AuthContext] loadCachedAuth: token exists but no cached data');
      return false;
    } catch (error) {
      logger.error('[AuthContext] loadCachedAuth: error', error);
      setState(prev => ({ ...prev, isLoading: false }));
      return false;
    }
  }, []);

  // Fetch fresh profile data from API and update cache
  const refreshProfileFromAPI = useCallback(async (hadCachedData: boolean) => {
    try {
      const isAuthenticated = await authService.isAuthenticated();

      if (!isAuthenticated) {
        if (!hadCachedData) {
          setState(prev => ({ ...prev, isLoading: false }));
        }
        return;
      }

      try {
        const profile = await authService.getProfile();

        // Cache the fresh data
        await authService.saveUser(profile.user);
        await authService.saveOrganization(profile.organization);

        // Update state with fresh data
        setState(prev => ({
          ...prev,
          user: profile.user,
          organization: profile.organization,
          isLoading: false,
          isAuthenticated: true,
        }));
      } catch (error: any) {
        logger.error('Failed to fetch profile:', error);
        // If it's a 401, the API client already tried to refresh and failed
        // In that case, or any auth error, log the user out
        if (error?.statusCode === 401) {
          await authService.logout();
          setState({
            user: null,
            organization: null,
            subscription: null,
            isLoading: false,
            isAuthenticated: false,
            connectStatus: null,
            isPaymentReady: false,
            connectLoading: false,
            biometricCapabilities: null,
            biometricEnabled: false,
          });
        } else {
          // For other errors (network, 404, 500, etc.), keep the user logged in with cached data
          // Just stop loading if we didn't have cached data
          if (!hadCachedData) {
            setState(prev => ({ ...prev, isLoading: false }));
          }
        }
      }
    } catch (error) {
      logger.error('Failed to refresh profile:', error);
      // If we didn't have cached data, stop loading
      if (!hadCachedData) {
        setState(prev => ({ ...prev, isLoading: false }));
      }
    }
  }, []);

  useEffect(() => {
    // Load cached data first (instant), then refresh from API in background
    loadCachedAuth().then((hadCachedData) => {
      refreshProfileFromAPI(hadCachedData);
    });
  }, [loadCachedAuth, refreshProfileFromAPI]);

  const signIn = async (email: string, password: string) => {
    // Reset session kicked state so API client and socket can operate normally
    apiClient.resetSessionKicked();
    const response = await authService.login({ email, password });

    setState(prev => ({
      ...prev,
      user: response.user,
      organization: response.organization,
      subscription: response.subscription || null,
      isLoading: false,
      isAuthenticated: true,
      connectLoading: true, // Reset to loading state for connect status
    }));
  };

  const signOut = async () => {
    // Clear state immediately for instant UI transition
    setState({
      user: null,
      organization: null,
      subscription: null,
      isLoading: false,
      isAuthenticated: false,
      connectStatus: null,
      isPaymentReady: false,
      connectLoading: false,
      biometricCapabilities: null,
      biometricEnabled: false,
    });
    // Clear local tokens + invalidate on server in background
    authService.logout().catch((error) => {
      logger.error('Logout error:', error);
    });
  };

  const refreshAuth = async () => {
    await refreshProfileFromAPI(true);
  };

  // Fetch Stripe Connect status
  const refreshConnectStatus = useCallback(async () => {
    try {
      const status = await stripeConnectApi.getStatus();
      // Only require chargesEnabled for Tap to Pay - payoutsEnabled is needed for receiving money
      // but users can still accept payments before completing full onboarding (bank account setup)
      const isReady = status.chargesEnabled;
      setState(prev => ({
        ...prev,
        connectStatus: status,
        isPaymentReady: isReady,
        connectLoading: false,
      }));
    } catch (error) {
      logger.error('Failed to fetch Connect status:', error);
      setState(prev => ({
        ...prev,
        connectStatus: null,
        isPaymentReady: false,
        connectLoading: false,
      }));
    }
  }, []);

  // Mark onboarding as complete
  const completeOnboarding = useCallback(async () => {
    try {
      await authService.completeOnboarding();
      // Update local user state
      setState(prev => ({
        ...prev,
        user: prev.user ? { ...prev.user, onboardingCompleted: true } : null,
      }));
      // Update cached user data
      if (state.user) {
        await authService.saveUser({ ...state.user, onboardingCompleted: true });
      }
    } catch (error) {
      logger.error('Failed to complete onboarding:', error);
      // Don't throw - onboarding completion is not critical
    }
  }, [state.user]);

  // Fetch Connect status when authenticated
  useEffect(() => {
    if (state.isAuthenticated && !state.isLoading) {
      refreshConnectStatus();
    }
  }, [state.isAuthenticated, state.isLoading, refreshConnectStatus]);

  // Load biometric capabilities and status on startup
  const refreshBiometricStatus = useCallback(async () => {
    const capabilities = await checkBiometricCapabilities();
    let enabled = false;
    if (capabilities.isAvailable) {
      enabled = await isBiometricLoginEnabled();
    }
    setState(prev => ({
      ...prev,
      biometricCapabilities: capabilities,
      biometricEnabled: enabled,
    }));
  }, []);

  const setBiometricEnabled = useCallback((enabled: boolean) => {
    setState(prev => ({ ...prev, biometricEnabled: enabled }));
  }, []);

  useEffect(() => {
    if (state.isAuthenticated && !state.isLoading) {
      refreshBiometricStatus();
    }
  }, [state.isAuthenticated, state.isLoading, refreshBiometricStatus]);

  // Prefetch avatar image into native cache
  useEffect(() => {
    if (state.user?.avatarUrl) {
      Image.prefetch(state.user.avatarUrl).catch(() => {});
    }
  }, [state.user?.avatarUrl]);

  return (
    <AuthContext.Provider value={{ ...state, signIn, signOut, refreshAuth, refreshConnectStatus, completeOnboarding, setBiometricEnabled, refreshBiometricStatus }}>
      {children}
    </AuthContext.Provider>
  );
}

export function useAuth() {
  const context = useContext(AuthContext);
  if (!context) {
    throw new Error('useAuth must be used within an AuthProvider');
  }
  return context;
}
